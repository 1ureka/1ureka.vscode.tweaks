# 1ureka's VSCode Extension

個人使用的 VSCode 擴充套件，整合多種實用功能。

# 1. 主要功能

- 提供閃光圖示按鈕在 explorer 面板與 editor 面板右上角，無縫整合進 VSCode 介面、非常省空間同時易於存取
- 按下後，會開啟快速前往選單，列出擴展中的大部分功能，同時利用圖示與文字排版來避免 overwhelm 使用者

## 圖片檢視器

- 設計用來取代 VSCode 預設圖片編輯器
- JS 層重新實現 object-fit: contain 的邏輯，使初始的骨架與圖片一定能完美對齊
- 支援滑鼠/觸控板縮放、平移、慣性滾動
- 右鍵選單可快速重設視角
- 內建吸管工具，一鍵取色並複製
- 右鍵選單提供 "導出為..." 選項，可將圖片另存為其他格式
- 導出完成後，使用者可以點擊通知中的 "開啟檔案" 快速比較差異

## 圖片牆

- 右鍵資料夾「以圖片牆顯示」，或使用命令面板「開啟圖片牆」瀏覽任意位置的圖片
- 提供不同布局模式與不同尺寸等偏好設定，可在右鍵選單即時切換
- 預設的瀑布流佈局，完美適應當資料夾中有各種尺寸比例圖片時的情況
- 響應式設計，無論面板如何分割或調整大小，都能正確排版並顯示圖片
- 漸進式載入機制，先快速掃描所有圖片的元資料，顯示骨架與排版，確保初始畫面無閃爍
- 自動壓縮圖片，經過測試在 50 張圖片且每張圖片都超過 50MB 也能高效顯示且不影響滾動體驗
- 分頁機制與快速元資料讀取，支援上達數千張圖片的資料夾
- 點擊圖片即可在圖片檢視器中開啟

## 圖片剪貼簿

- 在圖片檢視器右鍵選單有複製該張圖片的選項
- 在圖片牆右鍵任一圖片的選單中也有複製該張圖片的選項
- 在 Windows 系統上，複製的是圖片二進位資料而非單純路徑，包括 Windows 原生無法直接寫入的 WebP、TIFF 等格式
- 複製大型圖片時顯示實時進度，提供即時回饋

## 檔案元資料顯示

- 狀態列自動顯示當前檔案的建立時間、修改時間、大小等資訊
- 支援所有檔案類型，甚至包括 VsCode 原生無法開啟的任意二進位檔
- 適合管理包含非程式碼檔案的專案
- 針對圖片檔案提供特殊 UI，額外顯示解析度、長寬比、格式、色彩空間、通道等資訊

## 系統瀏覽器

- 右鍵資料夾「以系統瀏覽器顯示」，或使用命令面板「開啟系統瀏覽器」瀏覽任意位置的檔案
- 類似作業系統的檔案總管，但使用仿雲端硬碟的現代化介面，目標是再也不需要打開系統檔案總管
- 讓 VsCode 能夠更輕鬆的與外部互動，比如將下載資料夾中的檔案移動到工作區中
- 實現完整路由，包括瀏覽資料夾、回到上層、麵包屑導航、開啟檔案並顯示在 VsCode 編輯器、快速前往(Go to)等
- 採用虛擬化技術，即使資料夾包含數萬個檔案，也能維持原生檔案總管的效能表現
- 支援完整的表格操作，依指定欄位排序、切換升冪/降冪、篩選、選取等
- 支援完整的選取功能，包括單擊選取、Ctrl / Cmd 多選、Shift 範圍選取、全選、反選等
- 支援高效能的框選體驗，利用了不使用 React 狀態管理、採用原生事件、`requestAnimationFrame`、以及虛擬化帶來的純數學計算等方式等
- 框選時，會在靠近邊緣時有非線性加速滾動，在大量檔案時也能精準選取的同時，提供更自然的滾動體驗
- 提供完整的檔案操作閉環，包括新增資料夾、檔案；移動、複製、刪除選取的項目；重新命名等
- 剪貼簿採用內部狀態，確保沙盒安全性，並且不採取傳統的複製與剪下，而是一個[更符合現代的設計](#系統瀏覽器剪貼簿)
- 當真的發生檔案操作錯誤時，會產生詳細的錯誤報告，說明哪些檔案操作失敗、失敗原因
- 透過研究與分析 `fs-extra` 的行為與可能的競態條件，錯誤報告還分別在不同錯誤時，提供了完整的副作用/影響說明，確保錯誤是透明且可理解的
- 對常用的 150+ 檔案類型提供自訂圖示，避免直接顯示附檔名，全面採用直覺易懂的檔案類型描述
- 使用單一佇列系統處理所有 IO 非同步請求，避免競態條件並確保操作順序一致
- 從佇列系統中衍生出可靠的全域載入狀態指示，同時對於快速完成的操作顯示避免顯示，杜絕閃爍
- 載入指示採非侵入式設計，在下方以細長進度條顯示，使用者仍可繼續操作介面
- 載入視覺回饋採多層次設計，小於 50 ms 的載入不會有任何回饋，50 ms 會出現 table opacity 變化，超過 150 ms 則會開始顯示進度條
- 透過研究 VSCode 源碼，實現與檔案拖曳，支援將檔案從系統瀏覽器拖動到 VSCode 編輯器、 VSCode 檔案總管、原生作業系統檔案總管等
- 「在此開啟...」功能組，提供快速在當前路徑開啟新工作區、終端機或是該插件的圖片牆等

## 系統瀏覽器剪貼簿

- 在傳統介面中，「剪下」（Cut）和「複製」（Copy）在寫入剪貼簿時被區分開來，這延續了電腦還都是文字時的行為
- 然而，對於現代檔案系統而言，兩者在「寫入」階段的操作本質是相同的——都只是儲存檔案的參考，並不會立即刪除原始檔案
- 為了提供更直覺、更靈活的使用者體驗，本專案採用以下設計：
  - 統一寫入操作： 剪貼簿操作統一為「寫入剪貼簿」，不區分複製或剪下
  - 延後決策： 唯一的差異只在於「貼上」時的最終行為
  - 直覺化命名： 使用者在貼上時，介面會詢問是執行「複製」還是「移動」
- 使用者可以隨時在「複製」和「移動」之間切換意圖
- 避免了傳統介面中，如果最初選擇錯誤（例如選了複製，但後來想移動），必須返回原始資料夾重新操作的麻煩，從而大幅簡化了操作流程
- 移動也比起 "剪下 + 貼上" 更直覺，因為剪下並不算是一種口語化的動作描述
- 同時由於不需區分剪下與複製，寫入剪貼簿的項目也提供簡潔又直覺的視覺回饋

## 自訂樣式注入

- 比起 `Custom JS and CSS Loader` 能更安全注入自訂 CSS 到 VSCode 介面
- 透過採用修改而非刪除 CSP 的策略，通過安全完整性檢查
- 以及建構插件時將 CSS 內聯為字串，消除執行時的檔案 I/O 也減少了安全風險

## 外部應用程式整合 (Windows)

- 右鍵 `.blend` 檔案快速以裝置中最新的 Blender 開啟
- 右鍵 `.spp` 檔案快速以裝置中最新的 Substance Painter 開啟
- 右鍵 `.html` 檔案快速以預設瀏覽器開啟
- 命令選擇區也可直接啟動 Substance Painter 或 Blender
- 若應用位置特殊或想指定版本，可在 VsCode 設定中自訂路徑

---

# 2. 架構設計

面對擴展插件的複雜性，我認為 VSCode 原本的擴展架構與名詞模式過度抽象，為了通用性或技術準確性而引入過多層次，反而讓簡單的需求變得繁瑣。

因此，本專案選擇自行設計一套四層架構，其核心理念是**透過擴展原本名詞的語義範圍，實現更扁平、更彈性的結構**。

## Commands

**定位**：所有「在 VSCode 全域觸發、需註冊監聽」的事件來源

**涵蓋範圍**：

- VSCode commands (`registerCommand`)，因命令本質上也可視作一種「全域事件」
- 編輯器焦點切換（`onDidChangeActiveTextEditor`）
- 設定變更（`onDidChangeConfiguration`）
- 其他全域的事件監聽綁定
- 若命令與 Webview 高度相關，比如註冊在 `webview/context` 中的命令，可以使用 `forwardCommandToWebview`

## Providers

**定位**：所有「需要持續或長時間存在、管理、協調」的延伸主機視圖 (View) 與前後端溝通協調

**涵蓋範圍**：

- 官方 Provider（如 `CustomEditorProvider`）
- Webview Panel 建立、追蹤、銷毀
- StatusBar 生命週期管理
- 當有 Webview 需求時，將 Handlers 的處理函數包裝為 API，以及使用 `registerInvokeEvents`
- 為 Handlers 提供流程依賴注入，比如將 `vscode.window.showQuickPick` 作為 `getActionType` 參數傳入

## Handlers

**定位**：所有可被 Commands / Providers 呼叫的「無狀態」處理函數，可以是純函數，也可以是帶有 IO 的非同步函數

**涵蓋範圍**：

- 單純接收參數 → 使用 nodeJS 模組 → 回傳結果的純函數
- 用 `fs`、`path` 等模組進行檔案系統操作的非同步函數
- 處理圖片（`sharp`）等二進位檔案的非同步函數
- 若是流程式的，則會在簽名中帶有 `getInput`、`getActionType` 等 `() => Promise<any>` 的依賴需求，由 Providers 注入

## Webviews

**定位**：在瀏覽器環境中執行的前端應用，但不是每個功能都會用到，只有需要 Webview 的功能才會有這一層

**涵蓋範圍**：

- 使用 React 構建使用者介面
- 透過 Zustand 維護狀態
- 響應使用者互動事件（點擊、輸入等）
- 需要時透過 `invoke` 呼叫延伸主機 API、透過 `onReceiveCommand` 接收命令轉發

---

作者：1ureka | 版本：0.4.18
